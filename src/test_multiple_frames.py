import pandas as pd
import os
from pathlib import Path
from collections import defaultdict
import matplotlib.pyplot as plt
import numpy as np
from tqdm import tqdm
from itertools import product

# setting the path to the data
data_path = Path(r"C:/\Users/\vchar/\Downloads/\btcusd_1-min_data.csv")

# setting the year of interest
year = 2024

# setting the time frames
bar_sizes = [
    1, 2, 5, 10, 20, 30, 45, 60, 61, 75, 90, 120, 125, 150, 180, 
    210, 240, 247, 300, 360, 420, 480, 600, 720, 840, 960, 1150, 1440,
    1441
]

# specifying a strategy rules: those can be copied from any csv file generated by running GE
buy_signal_txt = "((price_data['btc_low'] > get_lag(price_data['btc_low'], lag=5)) & (price_data['btc_close'] > get_lag(price_data['btc_close'], lag=5)))"
buy_exit_txt = "signals.get_exit_point(((price_data['btc_low'] > get_lag(price_data['btc_low'], lag=5)) & (price_data['btc_close'] > get_lag(price_data['btc_close'], lag=5))), n_bars=10)"
sell_signal_txt = "((price_data['btc_low'] < get_lag(price_data['btc_low'], lag=5)) & (price_data['btc_close'] < get_lag(price_data['btc_close'], lag=5)))"
sell_exit_txt = "signals.get_exit_point(((price_data['btc_low'] < get_lag(price_data['btc_low'], lag=5)) & (price_data['btc_close'] < get_lag(price_data['btc_close'], lag=5))), n_bars=10)"

def change_frequency(data, freq, instrument_name='btc'):
    temp_df = data.copy()
    temp_df.set_index('datetime', inplace=True)
    temp_df = temp_df.resample(freq).agg({
            f'{instrument_name}_open': 'first',
            f'{instrument_name}_high': 'max',
            f'{instrument_name}_low': 'min',
            f'{instrument_name}_close': 'last',
            f'{instrument_name}_volume': 'sum'
        })
    temp_df.reset_index(inplace=True)
    return temp_df

def get_year_data_dict(data_path, time_freq, year):

    price_data = {}

    df = pd.read_csv(data_path)
    df['datetime'] = pd.to_datetime(df['datetime'])
    df = df[df['datetime'].dt.year==year]
    df.sort_values('datetime', ascending=True, inplace=True)
    df.reset_index(inplace=True, drop=True)

    temp_df_test = change_frequency(data=df, freq=f'{time_freq}min', instrument_name='btc')

    for col in temp_df_test.columns:
        price_data[col] = temp_df_test[col].values
    price_data['day_of_week'] = (temp_df_test['datetime'].dt.dayofweek + 1).values
    price_data['month'] = temp_df_test['datetime'].dt.month.values
    price_data['hour'] = temp_df_test['datetime'].dt.hour.values
    price_data['minute'] = temp_df_test['datetime'].dt.minute.values

    return price_data

def get_txt_code(
    buy_signal_txt, buy_exit_txt, sell_signal_txt, sell_exit_txt,
    fee=0.015, slippage=0.00005, inv_amount=700000, trade_size=0.5, max_lag=99
):

    text_code = f'''import os
CUR_DIR = os.getcwd()
# os.chdir('src')
import pandas as pd
import numpy as np
import vectorbt as vbt
import gc
from fitness.indicators import numba_indicators_nan, signals
from fitness.performance.helper_func import merge_buy_sell_pnl, get_drawdowns, get_pnl, get_lag
from fitness.performance.helper_func import trading_signals_buy, trading_signals_sell, change_exit
# os.chdir(CUR_DIR)
#from numba import njit
COMMISSION = {fee}
SLIPPAGE = {slippage}
AVAILABLE_CAPITAL = {inv_amount}
TRADE_SIZE = {trade_size}
MAX_LAG = {max_lag}
try:
    buy_idxs, buy_exit_idxs = trading_signals_buy(buy_signal={buy_signal_txt}, exit_signal={buy_exit_txt})
except:
    buy_idxs, buy_exit_idxs = [], []
try:
    sell_idxs, sell_exit_idxs = trading_signals_sell(sell_signal={sell_signal_txt}, exit_signal={sell_exit_txt})
except:
    sell_idxs, sell_exit_idxs = [], []
# if (len(buy_idxs) == 0 or len(buy_exit_idxs) == 0) and (len(sell_idxs) == 0 or len(sell_exit_idxs) == 0):
#     fitness = -9999999
#     avg_drawdown = -9999999
# else:
try:
    buy_idxs, buy_exit_idxs, sell_idxs, sell_exit_idxs = change_exit(buy_idxs, buy_exit_idxs, sell_idxs, sell_exit_idxs)
except:
    pass
if (len(buy_idxs) == 0 or len(buy_exit_idxs) == 0) and (len(sell_idxs) == 0 or len(sell_exit_idxs) == 0):
    total_return_p = np.nan
    sharpe_ratio = np.nan
    sortino_ratio = np.nan
    omega_ratio = np.nan
    md_duration_m = np.nan
    max_drawdown_p = np.nan
    calmar_ratio = np.nan
    return_md_r = np.nan
else:
    buy_entries = np.array([1 if i in buy_idxs else 0 for i in range(len(price_data['btc_open']))])
    buy_exits = np.array([1 if i in buy_exit_idxs else 0 for i in range(len(price_data['btc_open']))])
    sell_entries = np.array([1 if i in sell_idxs else 0 for i in range(len(price_data['btc_open']))])
    sell_exits = np.array([1 if i in sell_exit_idxs else 0 for i in range(len(price_data['btc_open']))])
    price_data_open = pd.Series(price_data['btc_open'], index=pd.to_datetime(price_data['datetime']))
    pf = vbt.Portfolio.from_signals(
        price_data_open, entries=buy_entries, exits=buy_exits, 
        init_cash=AVAILABLE_CAPITAL, fees=COMMISSION, 
        slippage=SLIPPAGE, size=TRADE_SIZE, 
        short_entries=sell_entries, short_exits=sell_exits
    )
    total_return_p = pf.stats()['Total Return [%]']
    sharpe_ratio = pf.stats()['Sharpe Ratio']
    sortino_ratio = pf.stats()['Sortino Ratio']
    omega_ratio = pf.stats()['Omega Ratio']
    md_duration_m = pf.stats()['Max Drawdown Duration'].total_seconds() / 60
    max_drawdown_p = pf.stats()['Max Drawdown [%]']
    calmar_ratio = pf.stats()['Calmar Ratio']
    n_trades = pf.stats()['Total Closed Trades']
    return_md_r = total_return_p / max_drawdown_p
gc.collect()'''
    
    return text_code

def create_save_figures(stat_name, stats_dict, figsize=(10, 4), fig_dir='multiple_frames_figures'):

    if not os.path.exists(fig_dir):
        os.mkdir(fig_dir)

    fig = plt.figure(figsize=figsize)

    stat_list = stats_dict[stat_name]

    bar_list = stats_dict['bar_size']

    plt.bar(np.arange(len(bar_list)), stat_list)
    plt.xticks(np.arange(len(bar_list)), bar_list, rotation=45)
    plt.title("VBT strategy")
    plt.xlabel('bar_size')
    plt.ylabel(stat_name)

    fig.savefig(os.path.join(fig_dir, f"{stat_name}.png"))

# creating performance dictionary over the specified year and time frames
performance_dict = defaultdict(list)

for bar_size in tqdm(bar_sizes):

    price_data = get_year_data_dict(data_path=data_path, time_freq=bar_size, year=year)
    
    text_code = get_txt_code(buy_signal_txt, buy_exit_txt, sell_signal_txt, sell_exit_txt)

    exec_dict = {'price_data': price_data}
    exec(text_code, exec_dict)

    try:
        performance_dict['n_trades'].append(exec_dict['n_trades'])
        performance_dict['total_return_p'].append(exec_dict['total_return_p'])
        performance_dict['return_md_r'].append(exec_dict['return_md_r'])
        performance_dict['calmar_ratio'].append(exec_dict['calmar_ratio'])
        performance_dict['drawdown'].append(exec_dict['max_drawdown_p'])
        performance_dict['drawdown_dur_m'].append(exec_dict['md_duration_m'])
        performance_dict['omega_ratio'].append(exec_dict['omega_ratio'])
        performance_dict['sharpe_ratio'].append(exec_dict['sharpe_ratio'])
        performance_dict['sortino_ratio'].append(exec_dict['sortino_ratio'])
        performance_dict['bar_size'].append(bar_size)
    except:
        pass

def filter_dict(perf_dict):

    perf_dict = {
        k: [
            perf_dict[k][i]
            for i in range(len(perf_dict[k])) 
            if perf_dict['total_return_p'][i] > 0
        ]
        for k in perf_dict.keys()
    }
    
    return perf_dict

# creating figures for different metrics: the image files will be generated inside multiple_frames_figures folder
create_save_figures(
    stat_name='total_return_p', stats_dict=filter_dict(performance_dict)
)

create_save_figures(
    stat_name='drawdown', stats_dict=filter_dict(performance_dict)
)

create_save_figures(
    stat_name='sharpe_ratio', stats_dict=filter_dict(performance_dict)
)

create_save_figures(
    stat_name='sortino_ratio', stats_dict=filter_dict(performance_dict)
)

create_save_figures(
    stat_name='return_md_r', stats_dict=filter_dict(performance_dict)
)

create_save_figures(
    stat_name='n_trades', stats_dict=filter_dict(performance_dict)
)